# 浏览器渲染原理

## 什么是渲染？
将字符串转换为每一个像素点信息
## 渲染时间点
网络进程开启多个网络线程去获取html，然后创建一个渲染任务给消息队列，等待渲染主线程执行
## 浏览器是如何渲染页面的？
当浏览器的网络线程收到**HTML**文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。
在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。
整个渲染流程分为多个阶段，分别是：HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画
每个阶段
1. 解析**HTML**，生成两棵树：**DOM**（Document Object Model）树和**CSSOM**（CSS Object Model）树。
解析过程中遇到**CSS**解析**CSS**，遇到**JS**执行**JS**。为了提高解析效率，会启动一个预解析的线程，率先下载**HTML**中的外部的**CSS**文件和外部的**JS**文件。
如果渲染主线程解析到`link`位置，此时外部的**CSS**文件还没有下载解析好，主线程不会等待，极细解析后续的**HTML**。这是因为下载和解析CSS的工作是在预解析线程中进行的。这就是**CSS**不会阻塞**HTML**解析的根本原因。
如果渲染主线程遇到`script`位置，会暂停解析**HTML**，转而等待**JS**文件下载好，并将全局代码解析执行完成后，才能继续解析**HTML**。这是因为JS代码的执行过程汇总可能会修改当前的**DOM**树，所以**DOM**树的生成必须暂停。这就好似**JS**会阻塞**HTML**解析的根本原因。
第一步完成后，会得到**DOM**树和**CSSOM**树，浏览器的默认样式、内部样式、外部样式和行内样式均会包含在**CSSOM**树中。
2. 样式计算，渲染主线程会遍历得到的**DOM**树，依次为树中的每个节点计算出它的最终样式，称之为**Computed Style**。在这一过程中，很多预设值会变成绝对值，比如颜色会转换为rgb；相对单位会转换为绝对单位等。
第二步完成后，会得到一颗带有样式的DOM树。
3. 布局，布局完成后会得到**布局**树，布局阶段会依次遍历**DOM**树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对应包含块的位置。
大部分时候，**DOM**树和**布局**树并非一一对应。
例如`display: none`的节点没有几何信息，因此不会产生到**布局**树；又比如使用了伪元素选择器，虽然**DOM**树中不存在这些伪元素节点，但它们有几何信息，所以会生成到**布局**树中。还有匿名行盒、匿名块盒等都会导致两者无法一一对应。
4. 分层，主线程会使用一套复杂的策略对整个**布局**树中进行分层。
分层的好处就在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。
滚动条、堆叠上下文、transform、opacity等样式都会或多或少影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。
5. 绘制，渲染主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。
6. 分块，绘制完成后，主线程将每个图层的绘制线程提交给合成线程，剩余工作将交由合成线程完成。
合成线程首先对每个图层进行分块，将其划分为更多的小区域。
它会从线程池中拿取多个线程来完成分块工作。
7. 光栅化，合成线程会将块信息交给**GPU**进程，以极高的速度完成光栅化。
**GPU**进程会开启多个线程完成光栅化，并且优先处理靠近视口区域的块。光栅化的结果，就是一块一块的位图。
8. 画，合成线程拿到每个层、每个块的位图后，生成一个个**指引（quard）**信息。
指引会标识出每个位图应该画到屏幕的哪个位置，以及考虑到旋转、缩放等变形。
变形发生在合成线程，与渲染主线程无关，这就是**transform**效率高的本质原因。
合成线程会把**quard**提交给**GPU**进程，由**GPU**进程产生系统调用，提交给**GPU**硬件，完成最终的屏幕成像。

## 什么是reflow？
**reflow**的本质就是重新计算layout树。
当进行了会影响**布局**树的操作后，需要重新计算**布局**树，会引发**layout**。
为了避免连续的多次操作导致**布局**树反复计算，浏览器会合并这些操作，当**JS**代码全部完成后再进行统一计算。所以，改动属性造成的**reflow**是异步完成的。
当**JS**获取布局属性时，就可能造成无法获取到最新的布局信息，所以浏览器反复权衡下，最终决定获取属性会立即触发**reflow**。
## 什么是repaint？
**repaint**的本质就是重新根据分层信息计算绘制指令。
当改动了可见样式后，就需要重新计算，会引发**repaint**。
由于元素的布局信息也属于可见样式，所以**reflow**一定会引起**repaint**。
## 为什么transform效率高？
因为**transform**既不会影响布局也不会影响绘制指令，它影响的只是渲染流程最后一个[画]阶段。由于[画]阶段在合成线程中完成，所以**transfom**的变化几乎不会影响渲染主线程。反而，渲染主线程无论如何忙碌，也不会影响**transform**的变化。